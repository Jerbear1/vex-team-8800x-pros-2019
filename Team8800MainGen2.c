#pragma config(Sensor, in1,    mobilePot,      sensorPotentiometer)
#pragma config(Sensor, in2,    liftRightPot,   sensorPotentiometer)
#pragma config(Sensor, in3,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    liftLeftPot,    sensorPotentiometer)
#pragma config(Sensor, in5,    driveGyro,      sensorGyro)
#pragma config(Sensor, dgtl1,  rightDriveEnc,  sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftDriveEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rollerEnc,      sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  MOSI,           sensorDigitalOut)
#pragma config(Sensor, dgtl8,  SCLK,           sensorDigitalOut)
#pragma config(Motor,  port1,           mobileGoal,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           driveBL,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveBR,       tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, None)
#pragma config(Motor,  port4,           driveFL,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           driveFR,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           swingingArm,   tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           roller,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           liftL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           liftR,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Declare VEX as the robot platform

#pragma platform(VEX)

// Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// **** Important programmer notes ****
//
// When upgrading ROBOTC the Robot Platform Settings are lost and must be reset
// otherwise compiler error will result. Ensure the following are set:
// 		Robot -> Platform Type -> VEX 2.0 Cortex
// 		Robot -> Platform Type -> VEX Robotics -> VEX 2.0 Cortex
// 		Robot -> Platform Type -> Natural Language (PLTW)
//
//
// Note: Sometime when upgrading FW on the controller and/or joystick, the FW for the
//       VEXNet Keys must also be upgraded. The symptom of needing this upgrade is a
//       failure of the controller and joystick to communicate with each other.
//
//
// Note: When RobotC refuses to download code to the robot, first try manually selecting the
//       COM port. If that doesn't work then it may be necessary reload the firmware. First
//       update the main FW and then the RobotC FW. Don't forget to rename robot afterwards.
//
//
// Variable info:
//
//		int, short, word - 2 bytes
//		long - 4 bytes
//		SensorValue() returns 2 byte value

// Control debugger windows by defining these pragmas
#pragma DebuggerWindows("debugStream")

#include "Team8800Lib.c"		// Utility routines to simplify programming
#include "Team8800Led.c"		// Routines to control the LED strip
#include "MultiTask.c"  // Motor slew control

// Delcarations

int number = 10;

// Initialize
void initialize();
void initializeGyro();
void selectTeamAlliance();

// Controller Input
//void processController();

// Autonomous
//void autonomousRoutines();

// Robot Action

//Functions
void moveLiftDown(int speed, int distance);
void moveArmOut();
void moveArmIn();
void moveArmOutAuto();
void moveArm(bool forward);
void moveLiftUp(int speed, int distance);
void moveLiftUpAuto(int speed, int distance);
void rollerIntake(int speed);
void rollerOutake(int speed, int distance);

void liftPIDControl(int position);
void autoDrivePIDControl (int distance, bool drive);
void autoGyroPIDControl (int setAngle, bool turn);
void autoDriveGyroPIDControl (int setAngle, int distance, float turnkp, float turnki, float turnkd, float drivekp, float driveki, float drivekd);
void autoLiftPIDControl (int position, int kp, int ki, int kd);

//Auto Functions
void moveMobileGoalOutAndDrive(int speed, int distance);
void moveMobileGoalInAndDrive(int speed, int distance);
void autoLiftControl (int height);
void drive(int left, int right);
void driveForward(int speed, int distance);
void driveBackward(int speed, int distance);
void turnLeft(int speed, int distance);
void turnRight(int speed, int distance);
void clearDriveEnc();
void moveMobileGoalOutAuto();
void moveMobileGoalInAuto();
void moveMobileGoalOut();
void moveMobileGoalIn();
void moveMobileGoalInDistance(int distance);
void rollerOutakeAuto(int speed, int distance);

void autoStackStep(int liftPos);

void autoStack (int level);
void postStacking();

// Constants and global vars
const byte MIN_JOYSTICK_THRESHOLD = 30;

const byte RED_ALLIANCE = 1;
const byte BLUE_ALLIANCE = 2;
byte allianceColor = BLUE_ALLIANCE;

const byte LEFT = 1;
const byte RIGHT = 2;
byte allianceSide = RIGHT;

const byte AUTONOMOUS_MODE_MOBILE_GOAL_20 = 1;
const byte AUTONOMOUS_MODE_CUBE_BACK_STAR = 2;
const byte AUTONOMOUS_MODE_FENCE = 3;
const byte AUTONOMOUS_MODE_SKILLS = 4;
const byte AUTONOMOUS_MODE_STACK_DRIVE = 5;
const byte AUTONOMOUS_MODE_STACK_PIPE = 6;
const byte AUTONOMOUS_MODE_STACK_BACK = 7;
const byte AUTONOMOUS_MODE_DRIVE_BLOCK = 8;
byte autonomousMode = AUTONOMOUS_MODE_MOBILE_GOAL_20;

const byte PRESET_LEVEL_ONE = 1;
const byte PRESET_LEVEL_TWO = 2;
const byte PRESET_LEVEL_THREE = 3;
const byte PRESET_LEVEL_FOUR = 4;
const byte PRESET_LEVEL_FIVE = 5;
const byte PRESET_LEVEL_SIX = 6;
const byte PRESET_LEVEL_SEVEN = 7;
const byte PRESET_LEVEL_EIGHT = 8;
const byte PRESET_LEVEL_NINE = 9;
const byte PRESET_LEVEL_TEN = 10;
const byte PRESET_LEVEL_ELEVEN = 11;
const byte PRESET_LEVEL_TWELVE = 12;
const byte PRESET_LEVEL_THIRTEEN = 13;
const byte PRESET_LEVEL_FOURTEEN = 14;
const byte PRESET_LEVEL_FIFTEEN = 15;
byte presetLevel = PRESET_LEVEL_ONE;

unsigned long autonomousStartTime;

const byte AUTONOMOUS = 1;
const byte USER_CONTROL = 2;
byte robotMode = 1;

bool presetLevelActive = false;
bool presetLevelJustActive = false;

bool boingyPointOn = true;
bool armBack = false;
bool armFront = true;

bool stacking = false;
bool stackPrev = false;
bool justStacked = false;

bool increaseStackLvl;

bool armIsBack = false;
bool armIsReallyBack;
bool armIsBackLvl1and2;
bool armIsForward;
bool liftLeftIsPosition4;
bool liftRightIsPosition4 = false;
bool liftIsPosition4Again = false;
bool liftIsPosition5;
bool liftIsPosition6;
bool liftIsDown = false;

bool liftLeftAtPosition;
bool liftRightAtPosition;
bool driveAtPosition;
bool turnAtPosition;

bool mobileGoalOut;

bool rollerIntaking = false;
bool outakeFinished = false;

bool btnSixUPressed = false;
bool btnSixDPressed = false;

bool presetLevelScrollUp = false;
bool presetLevelScrollDown = false;

bool timeUp = false;

bool mobileGoalIsOut;

int armPower;

int stackLevel = 1;
int prevStackLevel = 0;

int liftLeftPositionError = 65;
int liftRightPositionError = 65;
int drivePositionError = 1;
int turnPositionError = 1;
int turnDrivePositionError = 2;
int driveTurnPositionError = 200;
int armError = 2;

//Lift PID values
float liftLeftkp = 0.4;
float liftSharedki = 0.008;
float liftLeftkd = 2;

float liftRightkp = 0.4;
float liftRightkd = 2;

//Drive PID values
float drivekp = 0.63;
float driveki = 0.0000009;
float drivekd = 75;

//Turn PID values
float turnkp = 0.83;
float turnki = 0.000008;
float turnkd = 100;

//Turn Drive PID values
float turnDrivekp;
float turnDriveki;
float turnDrivekd;

//Drive Turn PID values
float driveTurnkp;
float driveTurnki;
float driveTurnkd;

float turnError;

int driveCurrent;
int gyroCurrent;
int overallCurrentLeft;
int overallCurrentRight;

int turnPower = 35;

int rollerSpeed;

void pre_auton()
{
	bStopTasksBetweenModes = true;

	clearDebugStream();
	writeDebugStreamLine("Pre-Autonomous...");

	initializeGyro();

	// Select alliance using LCD and indicate selection with LEDs
	selectTeamAlliance();
}

task autonomousRoutines()
{
	switch (autonomousMode) {
	case AUTONOMOUS_MODE_MOBILE_GOAL_20:
		if (allianceSide == RIGHT && allianceColor == BLUE_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				moveLiftUp(100, 700);

				//Drive
				if (time1(T2) > 500) {
					autoDriveGyroPIDControl(0, 1350, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2300) {

				if (mobileGoalIsOut) {
					moveMobileGoalIn();
					} else {
					motor[mobileGoal] = 50;
				}

				//Drive
				if (time1(T2) > 1600) {
					driveBackward(-100, -460);
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 1000) {
				//turn
				autoGyroPIDControl(-300, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1000) {
				//drive backward
				driveBackward(-100, -60);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(-1500, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();
			SensorValue[rollerEnc] = 0;

			while (time1(T2) < 2000) {
				moveMobileGoalOut();

				moveLiftUp(100, 500);

				rollerOutake(-100, 150);

				if (time1(T2) > 300) {
					drive(100, 100);
					wait1Msec(600);
					drive(0, 0);
				}
				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 600) {
				drive(-60, -60);
				waitInMilliseconds(400);
				drive(0, 0);
			}
			moveMobileGoalInAuto();

			} else if (allianceSide == LEFT && allianceColor == BLUE_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				moveLiftUp(100, 700);

				//Drive
				if (time1(T2) > 500) {
					autoDriveGyroPIDControl(0, 1350, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2300) {

				if (mobileGoalIsOut) {
					moveMobileGoalInAuto();
					} else {
					motor[mobileGoal] = 50;
				}

				//Drive
				if (time1(T2) > 1600) {
					driveBackward(-100, -460);
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 1800) {
					rollerOutakeAuto(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 1000) {
				//turn
				autoGyroPIDControl(300, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1000) {
				//drive backward
				driveBackward(-100, -60);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1000) {
				//turn
				autoGyroPIDControl(1500, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2000) {
				moveMobileGoalOut();

				moveLiftUp(100, 500);

				if (time1(T2) > 300) {
					drive(100, 100);
					wait1Msec(600);
					drive(0, 0);
				}
				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 600) {
				drive(-60, -60);
				waitInMilliseconds(400);
				drive(0, 0);
			}
			moveMobileGoalIn();

			} else if (allianceSide == RIGHT && allianceColor == RED_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				moveLiftUp(100, 700);

				//Drive
				if (time1(T2) > 500) {
					autoDriveGyroPIDControl(0, 1350, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2300) {

				if (mobileGoalIsOut) {
					moveMobileGoalInAuto();
					} else {
					motor[mobileGoal] = 50;
				}

				//Drive
				if (time1(T2) > 1600) {
					driveBackward(-100, -460);
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 1800) {
					rollerOutakeAuto(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 1000) {
				//turn
				autoGyroPIDControl(-300, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1000) {
				//drive backward
				driveBackward(-100, -60);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(-1500, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2000) {
				moveMobileGoalOut();

				moveLiftUp(100, 500);

				if (time1(T2) > 300) {
					drive(100, 100);
					wait1Msec(600);
					drive(0, 0);
				}
				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 600) {
				drive(-60, -60);
				waitInMilliseconds(400);
				drive(0, 0);
			}
			moveMobileGoalIn();

			} else if (allianceSide == LEFT && allianceColor == RED_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				moveLiftUp(100, 700);

				//Drive
				if (time1(T2) > 500) {
					autoDriveGyroPIDControl(0, 1350, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2300) {

				if (mobileGoalIsOut) {
					moveMobileGoalInAuto();
					} else {
					motor[mobileGoal] = 50;
				}

				//Drive
				if (time1(T2) > 1600) {
					driveBackward(-100, -460);
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 1800) {
					rollerOutakeAuto(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(300, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1000) {
				//drive backward
				driveBackward(-100, -60);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(1500, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2000) {
				moveMobileGoalOut();

				moveLiftUp(100, 500);

				if (time1(T2) > 300) {
					drive(100, 100);
					wait1Msec(600);
					drive(0, 0);
				}
				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 600) {
				drive(-60, -60);
				waitInMilliseconds(400);
				drive(0, 0);
			}
			moveMobileGoalIn();
		}

		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}

		break;

	case AUTONOMOUS_MODE_CUBE_BACK_STAR:

		/////////////////////////////////////////////////////////////////////////////AUTO 2///////////////////////////////////////////////
		//Apply passive power to roller
		if (allianceSide == LEFT) {
		motor [roller] = 40;

		clearTimer(T2);

		//move lift up
		while (time1(T2) < 1000) {
			if (time1(T2) < 1000) {
			moveLiftUp(70, 800);
		} else {
			motor[liftL] = 0;
			motor[liftL] = 0;
		}
	}

		waitInMilliseconds(300);

		//drive forward
		driveForward(60, 200);

		waitInMilliseconds(100);

		//move swinging arm out
		moveArmOutAuto();

		waitInMilliseconds(200);

		moveArmIn();
		motor[roller] = -127;

		waitInMilliseconds(200);

		driveBackward(-100, -700);

		waitInMilliseconds(200);

		clearTimer(T2);

		while (time1(T2) < 600) {
		autoDrivePIDControl(-300, true);
	}
		waitInMilliseconds(100);

 		driveForward(100, 3000);

	} else if (allianceSide == RIGHT) {
	motor [roller] = 40;

		clearTimer(T2);

		//move lift up
		while (time1(T2) < 1000) {
			if (time1(T2) < 1000) {
			moveLiftUp(70, 800);
		} else {
			motor[liftL] = 0;
			motor[liftL] = 0;
		}
	}

		waitInMilliseconds(300);

		//drive forward
		driveForward(60, 200);

		waitInMilliseconds(100);

		//move swinging arm out
		moveArmOutAuto();

		waitInMilliseconds(200);

		moveArmIn();
		motor[roller] = -127;

		waitInMilliseconds(200);

		driveBackward(-100, -70);

		waitInMilliseconds(200);

		clearTimer(T2);

		while (time1(T2) < 600) {
		autoDrivePIDControl(300, true);
	}

	waitInMilliseconds(100);

 		driveForward(100, 3000);
}
		break;

	case AUTONOMOUS_MODE_FENCE:

		////////////////////////////////////////////////////////////////////////////////AUTO 3/////////////////////////////////////////////////
		if (allianceSide == RIGHT && allianceColor == BLUE_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				moveLiftUp(100, 700);

				//Drive
				if (time1(T2) > 500) {
					autoDriveGyroPIDControl(0, 1350, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();
			SensorValue[rollerEnc] = 0;

			//Move Mobile goal in and start stacking second cone
			while (time1(T2) < 2200) {

				if (mobileGoalIsOut) {
					moveMobileGoalIn();
					} else {
					motor[mobileGoal] = 50;
				}

				if (time1(T2) > 1600 && time1(T2) < 2050) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					moveLiftUp(80, 600);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			moveArmOut();
			motor[roller] = 120;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 200, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			while (time1(T2) < 1000) {
				moveLiftDown(20, 550);
				driveBackward(-100, -580);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(-1700, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				moveMobileGoalOut();
				moveLiftUp(80, 500);
				motor[roller] = -100;

				drive(50, 90);
				waitInMilliseconds(500);
				drive(0, 0);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 300) {
				drive(-60, -100);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			if (mobileGoalIsOut) {
				moveMobileGoalInAuto();
				} else {
				motor[mobileGoal] = 50;
			}

			} else if (allianceSide == LEFT && allianceColor == BLUE_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				moveLiftUp(100, 700);

				//Drive
				if (time1(T2) > 500) {
					autoDriveGyroPIDControl(0, 1350, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2200) {

				if (mobileGoalIsOut) {
					moveMobileGoalInAuto();
					} else {
					motor[mobileGoal] = 50;
				}

				//Drive
				if (time1(T2) > 1600) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 200, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				moveArmOut();

				motor[roller] = 120;
				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			while (time1(T2) < 1000) {
				moveLiftDown(20, 550);
				driveBackward(-100, -580);
				if (time1(T2) > 200) {
					motor[roller] = -100;
					waitInMilliseconds(400);
					motor[roller] = 0;
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(-1700, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				moveMobileGoalOut();
				moveLiftUp(80, 500);
				motor[roller] = -100;

				drive(50, 50);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 300) {
				drive(-60, -60);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			if (mobileGoalIsOut) {
				moveMobileGoalInAuto();
				} else {
				motor[mobileGoal] = 50;
			}

			} else if (allianceSide == RIGHT && allianceColor == RED_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				moveLiftUp(100, 700);

				//Drive
				if (time1(T2) > 500) {
					autoDriveGyroPIDControl(0, 1350, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2200) {

				if (mobileGoalIsOut) {
					moveMobileGoalInAuto();
					} else {
					motor[mobileGoal] = 50;
				}

				//Drive
				if (time1(T2) > 1600) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 200, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				moveArmOut();

				motor[roller] = 120;
				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			while (time1(T2) < 1000) {
				moveLiftDown(20, 550);
				driveBackward(-100, -580);
				if (time1(T2) > 200) {
					motor[roller] = -100;
					waitInMilliseconds(400);
					motor[roller] = 0;
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(-1700, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				moveMobileGoalOut();
				moveLiftUp(80, 500);
				motor[roller] = -100;

				drive(50, 50);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 300) {
				drive(-60, -60);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			if (mobileGoalIsOut) {
				moveMobileGoalInAuto();
				} else {
				motor[mobileGoal] = 50;
			}

			} else if (allianceSide == LEFT && allianceColor == RED_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				moveLiftUp(100, 700);

				//Drive
				if (time1(T2) > 500) {
					autoDriveGyroPIDControl(0, 1350, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2200) {

				if (mobileGoalIsOut) {
					moveMobileGoalInAuto();
					} else {
					motor[mobileGoal] = 50;
				}

				//Drive
				if (time1(T2) > 1600) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 200, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				moveArmOut();

				motor[roller] = 120;
				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			while (time1(T2) < 1000) {
				moveLiftDown(20, 550);
				driveBackward(-100, -580);
				if (time1(T2) > 200) {
					motor[roller] = -100;
					waitInMilliseconds(400);
					motor[roller] = 0;
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(-1700, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				moveMobileGoalOut();
				moveLiftUp(80, 500);
				motor[roller] = -100;

				drive(50, 50);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 300) {
				drive(-60, -60);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			if (mobileGoalIsOut) {
				moveMobileGoalInAuto();
				} else {
				motor[mobileGoal] = 50;
			}
		}

		break;

	case AUTONOMOUS_MODE_SKILLS:

		//////////////////////////////////////////////////////////Auto 4/////////////////////////////////////

		if (allianceSide == RIGHT && allianceColor == BLUE_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 400);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				//Drive
				if (time1(T2) > 500 && time1(T2) < 700) {
					motorReq2[driveBL] = 90;
					motorReq2[driveBR] = 90;
					motorReq2[driveFL] = 90;
					motorReq2[driveFR] = 90;
				}
				//Drive
				if (time1(T2) > 700) {
					autoDriveGyroPIDControl(0, 1300, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Move Mobile goal in and start stacking second cone
			while (time1(T2) < 2200) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 500);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}
				if (mobileGoalIsOut) {
					moveMobileGoalIn();
					} else {
					motor[mobileGoal] = 50;
				}

				if (time1(T2) > 1600 && time1(T2) < 2050) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					moveLiftUp(80, 600);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			moveArmOut();
			motor[roller] = 120;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 300, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			while (time1(T2) < 1000) {
				moveLiftDown(20, 550);
				driveBackward(-100, -580);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 1000) {
				//turn
				autoGyroPIDControl(-300, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1000) {
				//drive backward
				driveBackward(-100, -60);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(-1400, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();
			SensorValue[rollerEnc] = 0;

			while (time1(T2) < 2000) {
				moveMobileGoalOut();

				moveLiftUp(100, 500);

				rollerOutake(-100, 150);

				if (time1(T2) > 300) {
					drive(100, 100);
					wait1Msec(600);
					drive(0, 0);
				}
				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 600) {
				drive(-60, -60);
				waitInMilliseconds(400);
				drive(0, 0);
			}
			moveMobileGoalInAuto();

			} else if (allianceSide == LEFT && allianceColor == BLUE_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				if (time1(T2) < 300) {
					moveLiftUp(60, 400);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				//Drive
				if (time1(T2) > 500 && time1(T2) < 700) {
					motorReq2[driveBL] = 90;
					motorReq2[driveBR] = 90;
					motorReq2[driveFL] = 90;
					motorReq2[driveFR] = 90;
				}
				//Drive
				if (time1(T2) > 700) {
					autoDriveGyroPIDControl(0, 1300, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Move Mobile goal in and start stacking second cone
			while (time1(T2) < 2200) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 500);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				if (mobileGoalIsOut) {
					moveMobileGoalIn();
					} else {
					motor[mobileGoal] = 50;
				}

				if (time1(T2) > 1600 && time1(T2) < 2050) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					moveLiftUp(80, 600);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			moveArmOut();
			motor[roller] = 120;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 300, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			while (time1(T2) < 1000) {
				moveLiftDown(20, 550);
				driveBackward(-100, -580);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 1000) {
				//turn
				autoGyroPIDControl(300, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1000) {
				//drive backward
				driveBackward(-100, -60);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(1400, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();
			SensorValue[rollerEnc] = 0;

			while (time1(T2) < 2000) {
				moveMobileGoalOut();

				if (time1(T2) < 700) {
					moveLiftUp(100, 500);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				rollerOutake(-100, 150);

				if (time1(T2) > 300) {
					drive(100, 100);
					wait1Msec(600);
					drive(0, 0);
				}
				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 600) {
				drive(-60, -60);
				waitInMilliseconds(400);
				drive(0, 0);
			}
			moveMobileGoalInAuto();

			} else if (allianceSide == RIGHT && allianceColor == RED_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 400);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				//Drive
				if (time1(T2) > 500 && time1(T2) < 700) {
					motorReq2[driveBL] = 90;
					motorReq2[driveBR] = 90;
					motorReq2[driveFL] = 90;
					motorReq2[driveFR] = 90;
				}
				//Drive
				if (time1(T2) > 700) {
					autoDriveGyroPIDControl(0, 1300, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Move Mobile goal in and start stacking second cone
			while (time1(T2) < 2200) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 500);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				if (mobileGoalIsOut) {
					moveMobileGoalIn();
					} else {
					motor[mobileGoal] = 50;
				}

				if (time1(T2) > 1600 && time1(T2) < 2050) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					moveLiftUp(80, 600);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			moveArmOut();
			motor[roller] = 120;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 300, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			while (time1(T2) < 1000) {
				moveLiftDown(20, 550);
				driveBackward(-100, -580);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 1000) {
				//turn
				autoGyroPIDControl(-300, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1000) {
				//drive backward
				driveBackward(-100, -60);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(-1400, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();
			SensorValue[rollerEnc] = 0;

			while (time1(T2) < 2000) {
				moveMobileGoalOut();

				moveLiftUp(100, 500);

				rollerOutake(-100, 150);

				if (time1(T2) > 300) {
					drive(100, 100);
					wait1Msec(600);
					drive(0, 0);
				}
				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 600) {
				drive(-60, -60);
				waitInMilliseconds(400);
				drive(0, 0);
			}
			moveMobileGoalInAuto();

			} else if (allianceSide == LEFT && allianceColor == RED_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 400);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				//Drive
				if (time1(T2) > 500 && time1(T2) < 700) {
					motorReq2[driveBL] = 90;
					motorReq2[driveBR] = 90;
					motorReq2[driveFL] = 90;
					motorReq2[driveFR] = 90;
				}
				//Drive
				if (time1(T2) > 700) {
					autoDriveGyroPIDControl(0, 1300, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Move Mobile goal in and start stacking second cone
			while (time1(T2) < 2200) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 500);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}
				if (mobileGoalIsOut) {
					moveMobileGoalIn();
					} else {
					motor[mobileGoal] = 50;
				}

				if (time1(T2) > 1600 && time1(T2) < 2050) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					moveLiftUp(80, 600);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			moveArmOut();
			motor[roller] = 120;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 300, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			while (time1(T2) < 1000) {
				moveLiftDown(20, 550);
				driveBackward(-100, -580);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(200);

			while (time1(T2) < 1000) {
				//turn
				autoGyroPIDControl(300, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1000) {
				//drive backward
				driveBackward(-100, -60);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(1400, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();
			SensorValue[rollerEnc] = 0;

			while (time1(T2) < 2000) {
				moveMobileGoalOut();

				moveLiftUp(100, 500);

				rollerOutake(-100, 150);

				if (time1(T2) > 300) {
					drive(100, 100);
					wait1Msec(600);
					drive(0, 0);
				}
				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 600) {
				drive(-60, -60);
				waitInMilliseconds(400);
				drive(0, 0);
			}
			moveMobileGoalInAuto();

		}

		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}
		break;

	case AUTONOMOUS_MODE_STACK_DRIVE:
		/////////////////////////////////////////////////////////////////////////////AUTO 5////////////////////////////////
		if (allianceSide == RIGHT && allianceColor == BLUE_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 400);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				//Drive
				if (time1(T2) > 500 && time1(T2) < 700) {
					motorReq2[driveBL] = 90;
					motorReq2[driveBR] = 90;
					motorReq2[driveFL] = 90;
					motorReq2[driveFR] = 90;
				}
				//Drive
				if (time1(T2) > 700) {
					autoDriveGyroPIDControl(0, 1300, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Move Mobile goal in and start stacking second cone
			while (time1(T2) < 2200) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 500);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}
				if (mobileGoalIsOut) {
					moveMobileGoalIn();
					} else {
					motor[mobileGoal] = 50;
				}

				if (time1(T2) > 1600 && time1(T2) < 2050) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					moveLiftUp(80, 600);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Start intaking second cone
			moveArmOut();
			motor[roller] = 120;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 260, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();
			SensorValue[rollerEnc] = 0;

			//Start stacking second cone
			while (time1(T2) < 1000) {
				if (time1(T2) < 750) {
					moveLiftDown(80, 400);
				}

				if (time1(T2) > 750) {
					moveLiftUp(80, 600);
				}

				if (time1(T2) > 750) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			//Start intaking third cone
			moveArmOut();
			motor[roller] = 127;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 230, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1750) {
				moveLiftDown(20, 550);
				driveBackward(-100, -700);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(150);

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(-1850, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				moveMobileGoalOut();
				moveLiftUp(80, 500);
				motor[roller] = -100;

				if (time1(T2) < 1000) {
					drive(45, 85);
					} else {
					drive(0, 0);
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 300) {
				drive(-50, -127);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			if (mobileGoalIsOut) {
				moveMobileGoalInAuto();
				} else {
				motor[mobileGoal] = 50;
			}

			} else if (allianceSide == LEFT && allianceColor == BLUE_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 400);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				//Drive
				if (time1(T2) > 500 && time1(T2) < 700) {
					motorReq2[driveBL] = 90;
					motorReq2[driveBR] = 90;
					motorReq2[driveFL] = 90;
					motorReq2[driveFR] = 90;
				}
				//Drive
				if (time1(T2) > 700) {
					autoDriveGyroPIDControl(0, 1300, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Move Mobile goal in and start stacking second cone
			while (time1(T2) < 2200) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 500);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}
				if (mobileGoalIsOut) {
					moveMobileGoalIn();
					} else {
					motor[mobileGoal] = 50;
				}

				if (time1(T2) > 1600 && time1(T2) < 2050) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					moveLiftUp(80, 600);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Start intaking second cone
			moveArmOut();
			motor[roller] = 127;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 260, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();
			SensorValue[rollerEnc] = 0;

			//Start stacking second cone
			while (time1(T2) < 1000) {
				if (time1(T2) < 750) {
					moveLiftDown(80, 400);
				}

				if (time1(T2) > 750) {
					moveLiftUp(80, 600);
				}

				if (time1(T2) > 750) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			//Start intaking third cone
			moveArmOut();
			motor[roller] = 120;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 230, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1950) {
				moveLiftDown(20, 550);
				driveBackward(-100, -800);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(150);

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(1840, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				moveMobileGoalOut();
				moveLiftUp(80, 500);
				motor[roller] = -100;

				if (time1(T2) < 700) {
					drive(85, 45);
					} else {
					drive(0, 0);
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 300) {
				drive(-50, -127);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			if (mobileGoalIsOut) {
				moveMobileGoalInAuto();
				} else {
				motor[mobileGoal] = 50;
			}
			} else if (allianceSide == RIGHT && allianceColor == RED_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 400);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				//Drive
				if (time1(T2) > 500 && time1(T2) < 700) {
					motorReq2[driveBL] = 90;
					motorReq2[driveBR] = 90;
					motorReq2[driveFL] = 90;
					motorReq2[driveFR] = 90;
				}
				//Drive
				if (time1(T2) > 700) {
					autoDriveGyroPIDControl(0, 1300, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Move Mobile goal in and start stacking second cone
			while (time1(T2) < 2200) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 500);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}
				if (mobileGoalIsOut) {
					moveMobileGoalIn();
					} else {
					motor[mobileGoal] = 50;
				}

				if (time1(T2) > 1600 && time1(T2) < 2050) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					moveLiftUp(80, 600);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Start intaking second cone
			moveArmOut();
			motor[roller] = 120;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 260, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();
			SensorValue[rollerEnc] = 0;

			//Start stacking second cone
			while (time1(T2) < 1000) {
				if (time1(T2) < 750) {
					moveLiftDown(80, 400);
				}

				if (time1(T2) > 750) {
					moveLiftUp(80, 600);
				}

				if (time1(T2) > 750) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			//Start intaking third cone
			moveArmOut();
			motor[roller] = 127;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 230, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1750) {
				moveLiftDown(20, 550);
				driveBackward(-100, -700);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(150);

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(-1840, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				moveMobileGoalOut();
				moveLiftUp(80, 500);
				motor[roller] = -100;

				if (time1(T2) < 1000) {
					drive(45, 85);
					} else {
					drive(0, 0);
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 300) {
				drive(-50, -127);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			if (mobileGoalIsOut) {
				moveMobileGoalInAuto();
				} else {
				motor[mobileGoal] = 50;
			}

			} else if (allianceSide == LEFT && allianceColor == RED_ALLIANCE) {
			motor[roller] = 40;

			clearTimer(T2);

			while (time1(T2) < 3000) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 400);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}

				//Drive
				if (time1(T2) > 500 && time1(T2) < 700) {
					motorReq2[driveBL] = 90;
					motorReq2[driveBR] = 90;
					motorReq2[driveFL] = 90;
					motorReq2[driveFR] = 90;
				}
				//Drive
				if (time1(T2) > 700) {
					autoDriveGyroPIDControl(0, 1300, 1, 0.00015, 0.5, 0.00002, 0.000000000079, 1.3);
				}

				//Move mobile goal lifter out
				if (!mobileGoalIsOut) {
					moveMobileGoalOut();
					} else {
					motor[mobileGoal] = -50;
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Move Mobile goal in and start stacking second cone
			while (time1(T2) < 2200) {

				if (time1(T2) < 300) {
					moveLiftUp(100, 500);
					} else {
					motor[liftL] = 0;
					motor[liftR] = 0;
				}
				if (mobileGoalIsOut) {
					moveMobileGoalIn();
					} else {
					motor[mobileGoal] = 50;
				}

				if (time1(T2) > 1600 && time1(T2) < 2050) {
					moveLiftDown(50, 400);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					moveLiftUp(80, 600);
					//autoDriveGyroPIDControl(0, -1200, 1, 0.00015, 1.0, 1, 0.0000002, 0.4);
				}

				if (time1(T2) > 2050) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			//Start intaking second cone
			moveArmOut();
			motor[roller] = 127;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 260, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();
			SensorValue[rollerEnc] = 0;

			//Start stacking second cone
			while (time1(T2) < 1000) {
				if (time1(T2) < 750) {
					moveLiftDown(80, 400);
				}

				if (time1(T2) > 750) {
					moveLiftUp(80, 600);
				}

				if (time1(T2) > 750) {
					rollerOutake(-100, 150);
				}

				wait1Msec(20);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();


			//Start intaking third cone
			moveArmOut();
			motor[roller] = 120;

			while (time1(T2) < 1500) {
				autoDriveGyroPIDControl(0, 230, 1, 0.00015, 0.5, 1, 0.000079, 0.000003);

				moveLiftDown(50, 300);

				if (time1(T2) > 1000) {
					motor[roller] = 40;
					moveLiftUp(100, 550);
				}
				if (time1(T2) > 1300) {
					moveArmIn();
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1950) {
				moveLiftDown(20, 550);
				driveBackward(-100, -800);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			wait1Msec(150);

			while (time1(T2) < 2000) {
				//turn
				autoGyroPIDControl(1840, true);
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 1500) {
				moveMobileGoalOut();
				moveLiftUp(80, 500);
				motor[roller] = -100;

				if (time1(T2) < 700) {
					drive(85, 45);
					} else {
					drive(0, 0);
				}
			}

			drive(0, 0);
			clearTimer(T2);
			clearDriveEnc();

			while (time1(T2) < 300) {
				drive(-50, -127);
				waitInMilliseconds(200);
				drive(0, 0);
			}

			if (mobileGoalIsOut) {
				moveMobileGoalInAuto();
				} else {
				motor[mobileGoal] = 50;
			}
		}

		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}

		break;

	case AUTONOMOUS_MODE_STACK_PIPE:
		if (allianceSide == LEFT) {
			clearTimer(T2);
			while (time1(T2) < 800) {
				autoGyroPIDControl(-250, true);
			}

			clearTimer(T2);
			drive(0, 0);

			while (time1(T2) < 2400) {
				drive(127, 127);
			}

			drive(0, 0);

		} else if (allianceSide == RIGHT) {
			clearTimer(T2);
			while (time1(T2) < 800) {
				autoGyroPIDControl(250, true);
			}

			clearTimer(T2);
			drive(0, 0);

			while (time1(T2) < 2400) {
				drive(127, 127);
			}

			drive(0, 0);
		}

		if (allianceColor == BLUE_ALLIANCE) {
			theaterChaseTask(0, 0, 127, 50, 15000);
			} else {
			theaterChaseTask(127, 0, 0, 50, 15000);
		}

		break;

	case AUTONOMOUS_MODE_STACK_BACK:

		break;

	case AUTONOMOUS_MODE_DRIVE_BLOCK:

		break;
	}
}

task autonomous()
{
	robotMode = AUTONOMOUS;

	autonomousStartTime = nSysTime;
	writeDebugStreamLine("Starting Autonomous...");

	initialize();

	if (false) AutonomousCodePlaceholderForTesting();  // complains if I remove this

	startTask(autonomousRoutines);
}

task ProcessController() {
	while(true) {

		/*
		Main Controller:
		joysticks = drive

		Partner Contorller:
		right joystick = catapult
		*/

		// --- Joysticks to control robot driving (main controller only)

		static byte rightJoystickY, leftJoystickY, prevRightJoystickY = 0, prevLeftJoystickY = 0;

		rightJoystickY = readRightJoystickYAxis();
		leftJoystickY = readLeftJoystickYAxis();

		static bool rightDriveMoving = false;
		if (abs(rightJoystickY) > MIN_JOYSTICK_THRESHOLD) {
			rightDriveMoving = true;
			motorReq2[driveFR] = rightJoystickY;
			motorReq2[driveBR] = rightJoystickY;
			writeDebugStreamLine("Right: %d%%", rightJoystickY);
			} else {
			rightDriveMoving = false;
			motorReq2[driveFR] = 0;
			motorReq2[driveBR] = 0;
		}

		static bool leftDriveMoving = false;
		if (abs(leftJoystickY) > MIN_JOYSTICK_THRESHOLD) {
			leftDriveMoving = true;
			motorReq2[driveFL] = leftJoystickY;
			motorReq2[driveBL] = leftJoystickY;
			writeDebugStreamLine("Left: %d%%", leftJoystickY);
			} else {
			leftDriveMoving = false;
			motorReq2[driveFL] = 0;
			motorReq2[driveBL] = 0;
		}

		if (!stacking) {
			if (isButtonPressed(Btn8RXmtr2)) {
				armIsBack = true;
				} else if (isButtonPressed(Btn8LXmtr2)) {
				armIsBack = false;
			}

			if (armIsBack) {
				moveArmOut();
				} else if (!armIsBack) {
				moveArmIn();
			}
		}

		//Mobile Goal control on joystick
		if (isButtonPressed(Btn8U)) {
			mobileGoalOut = true;
			} else if (isButtonPressed(Btn8D)) {
			mobileGoalOut = false;
		}

		if (isButtonPressed(Btn8R)) {
			moveMobileGoalOut();
			} else if (isButtonPressed(Btn8L)) {
			moveMobileGoalIn();
			} else if (mobileGoalOut) {
			moveMobileGoalOut();
			} else if (!mobileGoalOut) {
			moveMobileGoalIn();
		}

		//Roller control
		if (!stacking) {
			if (isButtonPressed(Btn6DXmtr2)) {
				motor[roller] = -127;
				} else if (isButtonPressed(Btn6UXmtr2)) {
				motor[roller] = 127;
				} else {
				motor[roller] = 25;
			}
		}

		//Move lift
		if (!stacking) {
			if (isButtonPressed(Btn5UXmtr2)) {
				motor[liftL] = 127;
				motor[liftR] = 127;
				//liftPIDControl(1000);
				} else if (isButtonPressed(Btn5DXmtr2)) {
				motor[liftL] = -90;
				motor[liftR] = -90;
				//liftPIDControl(500);
				} else if (isButtonPressed(Btn7LXmtr2)) {
				liftPIDControl(600);
				} else {
				motor[liftL] = 0;
				motor[liftR] = 0;
			}
		}

		//Activate curent level
		if (isButtonPressed(Btn8UXmtr2)) {
			stacking = true;
		}

		if (stacking) {
			autoStack(stackLevel);
			} else if (stackPrev) {
			autoStack(prevStackLevel);
			} else if (justStacked) {
			postStacking();
		}

		//Activate Stack
		/*if (isButtonPressed(Btn7RXmtr2)) {
		liftLeftAtPosition = true;
		liftRightAtPosition = true;
		}*/

		//Activate last level
		if (isButtonPressed(Btn8DXmtr2)) {
			stackPrev = true;
		}

		//Increase stack level
		if (isButtonPressed(Btn8UXmtr2) && increaseStackLvl) {
			prevStackLevel ++;
			stackLevel ++;
			increaseStackLvl = false;
		}

		//Deactivate stacking emergency
		if (isButtonPressed(Btn7UXmtr2)) {
			stacking = false;
			justStacked = false;
			stackPrev = false;
		}

		//Deactivate stacking reset to 1
		if (isButtonPressed(Btn7DXmtr2)) {
			stacking = false;
			justStacked = false;
			stackPrev = false;
			stackLevel = 1;
			prevStackLevel = 0;
		}

		//writeDebugStreamLine("stack level %d", stackLevel);
		//writeDebugStreamLine("Prev stack level, %d", prevStackLevel);
		//writeDebugStreamLine("mobile,                                                                           %d", SensorValue[mobilePot]);
		//writeDebugStreamLine("               roller Enc, %d", SensorValue[rollerEnc]);
		writeDebugStreamLine("arm pot,                                                    %d", SensorValue[armPot]);
		//writeDebugStreamLine("arm power,                                                    %d", armPower );
		//writeDebugStreamLine("left pot, %d", SensorValue[liftLeftPot]);
		//writeDebugStreamLine("right pot,                    %d", SensorValue[liftRightPot]);
		//writeDebugStreamLine("Increase Stack level,                    %d", increaseStackLvl);


		//writeDebugStreamLine("right drive enc                    %d", SensorValue[rightDriveEnc]);
		//writeDebugStreamLine("left drive enc        %d", SensorValue[leftDriveEnc]);

		//writeDebugStreamLine("Gyro Values,      %d", SensorValue(driveGyro));
		//writeDebugStreamLine("Lift right pot,      %d", SensorValue(liftRightPot));
		//writeDebugStreamLine("						Lift Left pot,      %d", SensorValue(liftLeftPot));

		datalogAddValueWithTimeStamp(6, SensorValue[armPot]);
		datalogAddValueWithTimeStamp(5, armPower);
		//datalogAddValueWithTimeStamp(2, SensorValue[armPot]);

		//datalogAddValueWithTimeStamp(0, SensorValue[liftLeftPot]);
		//datalogAddValueWithTimeStamp(1, SensorValue[liftRightPot]);

		if (isButtonClick(Btn7U)) {
			theaterChaseTask(127, 0, 127, 127, 15000);
		}

		if (isButtonClick(Btn7R)) {
			theaterChaseTask(0, 0, 127, 127, 15000);
		}

		if (isButtonClick(Btn7L)) {
			theaterChaseTask(127, 0, 0, 127, 15000);
		}

		if (isButtonClick(Btn7D)) {
			rainbowCycleTask(0, 15000);
		}

		// --- Choose alliance if both Left & Right LCD Buttons are pressed

		if ((nLCDButtons & (kButtonLeft | kButtonRight)) == (kButtonLeft | kButtonRight)) {
			selectTeamAlliance();
		}

		//writeDebugStreamLine("value Arm pot %d", SensorValue[armPot]);

		wait1Msec(15);
	}
}

task usercontrol()
{
	robotMode = USER_CONTROL;

	if (false) CodePlaceholderForTesting();	// complains if I remove this

	writeDebugStreamLine("Starting User Control...");
	writeDebugStreamLine("Main battery level: %3.2f", nAvgBatteryLevel * 0.001);
	writeDebugStreamLine("Backup battery level: %3.2f", BackupBatteryLevel * 0.001);

	initialize();

	startTask(MotorSlewRateTask);
	startTask(ProcessController);
}

void initialize()
{
	// Library routines thread
	startTask(activateLib);

	// LED strip routines thread
	setupLedStrip();

	//Clear Sensors
	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
	SensorValue[rollerEnc] = 0;

	stacking = false;
	stackPrev = false;
	liftLeftAtPosition = false;
	liftRightAtPosition = false;
	armIsReallyBack = false;
	increaseStackLvl = false;
	justStacked = false;
	outakeFinished = false;

	datalogClear();

	presetLevel = PRESET_LEVEL_ONE;
}

void timerCallback(unsigned int timerId)
{

}

void selectTeamAlliance()
{
	// Defaults
	allianceColor = BLUE_ALLIANCE;
	allianceSide = RIGHT;
	autonomousMode = AUTONOMOUS_MODE_MOBILE_GOAL_20;
	//return;

	//SensorValue[ledGreen] = 0;
	//SensorValue[ledRed] = 0;

	// Zero out encoder positions

	// Clear LCD and turn on backlight
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	// Display alliance selection
	displayLCDString(0, 0, " Team Color  ");
	displayLCDString(1, 0, " Blue       Red ");

	bool allianceSelected = false;
	while (!allianceSelected) {	//bIfiRobotDisabled
		// Wait for button press
		switch (getLcdButtons()) {
		case kButtonLeft:
			allianceColor = BLUE_ALLIANCE;
			displayLCDString(1, 0, "[Blue]      Red ");
			allianceSelected = true;
			break;

		case kButtonRight:
			allianceColor = RED_ALLIANCE;
			displayLCDString(1, 0, "Blue       [Red]");
			allianceSelected = true;
			break;
		}

		wait1Msec(10);
	}

	// Display autonomous selection
	wait1Msec(500);

	// Display alliance selection
	displayLCDString(0, 0, " Team Side  ");
	displayLCDString(1, 0, " Left     Right ");

	bool sideSelected = false;
	while (!sideSelected) {	//bIfiRobotDisabled
		// Wait for button press
		switch (getLcdButtons()) {
		case kButtonLeft:
			allianceSide = LEFT;
			displayLCDString(1, 0, "[Left]    Right ");
			sideSelected = true;
			break;

		case kButtonRight:
			allianceSide = RIGHT;
			displayLCDString(1, 0, "Left     [Right]");
			sideSelected = true;
			break;
		}
		wait1Msec(10);
	}



	// Display autonomous selection
	wait1Msec(500);

	displayLCDString(0, 0, "Autonomous Mode ");
	displayLCDString(1, 0, "Full  Min  None ");

	bool autonomousSelected = false;
	int scrollCount = 1;
	byte scrolledAuto = AUTONOMOUS_MODE_MOBILE_GOAL_20;
	while (!autonomousSelected) {
		// Wait for button press
		if(nLCDButtons == 1) {
			scrollCount -= 1;
		}
		if(nLCDButtons == 4) {
			scrollCount += 1;
		}
		if(nLCDButtons == 2) {
			autonomousMode = scrolledAuto;
			autonomousSelected = true;
		}

		switch (scrollCount) {
		case 1:
			scrolledAuto = AUTONOMOUS_MODE_MOBILE_GOAL_20;
			displayLCDString(1, 0, "[1]2 3 4 5 6 7 8 ");
			wait1Msec(200);
			break;

		case 2:
			scrolledAuto = AUTONOMOUS_MODE_CUBE_BACK_STAR;
			displayLCDString(1, 0, " 1[2]3 4 5 6 7 8 ");
			wait1Msec(200);
			break;

		case 3:
			scrolledAuto = AUTONOMOUS_MODE_FENCE;
			displayLCDString(1, 0, " 1 2[3]4 5 6 7 8 ");
			wait1Msec(200);
			break;

		case 4:
			scrolledAuto = AUTONOMOUS_MODE_SKILLS;
			displayLCDString(1, 0, " 1 2 3[4]5 6 7 8 ");
			wait1Msec(200);
			break;

		case 5:
			scrolledAuto = AUTONOMOUS_MODE_STACK_DRIVE;
			displayLCDString(1, 0, " 1 2 3 4[5]6 7 8 ");
			wait1Msec(200);
			break;

		case 6:
			scrolledAuto = AUTONOMOUS_MODE_STACK_PIPE;
			displayLCDString(1, 0, " 1 2 3 4 5[6]7 8 ");
			wait1Msec(200);
			break;

		case 7:
			scrolledAuto = AUTONOMOUS_MODE_STACK_BACK;
			displayLCDString(1, 0, " 1 2 3 4 5 6[7]8 ");
			wait1Msec(200);
			break;

		case 8:
			scrolledAuto = AUTONOMOUS_MODE_DRIVE_BLOCK;
			displayLCDString(1, 0, " 1 2 3 4 5 6 7[8]");
			wait1Msec(200);
			break;
		}

		wait1Msec(10);
	}

	wait1Msec(500);

	// Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
}

void initializeGyro() {
	writeDebugStreamLine("Gyro before initialize %d", SensorValue[in8]);

	SensorType(driveGyro) = sensorNone;
	wait1Msec(1000);
	SensorType(driveGyro) = sensorGyro;
	wait1Msec(2000);

	writeDebugStreamLine("Gyro after initialize %d", SensorValue[in8]);
}

void moveArmOut () {
	if (SensorValue[armPot] > 1500) {
		motor[swingingArm] = 120;
		armPower = 120;
		} else if (SensorValue[armPot] <= 1500) {
		motor[swingingArm] = 0;
		armPower = 0;
		armIsReallyBack = false;
	}
}

void moveArmIn () {
	if (SensorValue[armPot] < 3200) {
		motor[swingingArm] = -120;
		armPower = -120;
		writeDebugStreamLine("swinging arm pot %d", SensorValue[armPot]);
		} else if (SensorValue[armPot] >= 3200) {
		motor[swingingArm] = 0;
		armPower = 0;
		armIsReallyBack = true;
	}
}

void moveArmOutAuto() {
	while(SensorValue[armPot] > 2000) {
		motor[swingingArm] = 100;
	}
	motor[swingingArm] = 0;
}

void moveArm (bool forward) {
	if (forward) {
		moveArmOut();
		} else {
		moveArmIn();
	}
}

void rollerIntake(int speed) {
	motor[roller] = speed;
	rollerSpeed = speed;
	//	writeDebugStreamLine("Set speed %d", rollerSpeed);
}

void rollerOutake(int speed, int distance) {
	if (distance > SensorValue[rollerEnc]) {
		motor[roller] = speed;
		} else {
		motor [roller] = 0;
		outakeFinished = true;
	}
}

void rollerOutakeAuto(int speed, int distance) {
	while (distance > SensorValue[rollerEnc]) {
		motor[roller] = speed;
	}
	motor [roller] = 0;
}

//Drive function for auto
void drive(int left, int right) {
	turnMotor(driveFL, left);
	turnMotor(driveFR, right);
	turnMotor(driveBL, left);
	turnMotor(driveBR, right);
}
//Drive function with encoders for auto
void driveForward(int speed, int distance) {
	while (SensorValue[rightDriveEnc] < distance && SensorValue[leftDriveEnc] < distance) {
		writeDebugStreamLine(" Left Encoder: %d", SensorValue[leftDriveEnc]);
		writeDebugStreamLine(" Right Encoder: %d", SensorValue[rightDriveEnc]);
		writeDebugStreamLine("Moving forward");
		drive(speed, speed);
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
	writeDebugStreamLine("Front Left Encoder: %d", SensorValue[leftDriveEnc]);
	writeDebugStreamLine("Front Right Encoder: %d", SensorValue[rightDriveEnc]);
}

void driveBackward(int speed, int distance) {
	while (SensorValue[rightDriveEnc] > distance && SensorValue[leftDriveEnc] > distance) {
		drive(speed, speed);
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void turnLeft(int speed, int distance) {
	while (SensorValue[leftDriveEnc] < distance && SensorValue[rightDriveEnc] > (-distance)) {
		drive(-speed, speed);
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void turnRight(int speed, int distance) {
	while (SensorValue[leftDriveEnc] > (-distance) && SensorValue[rightDriveEnc] < distance) {
		drive(speed, -speed);
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void clearDriveEnc() {
	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void  moveMobileGoalIn() {
	if (SensorValue[mobilePot] < 3100) {
		motor[mobileGoal] = 127;
		mobileGoalIsOut = true;
		} else {
		motor[mobileGoal] = 40;
		mobileGoalIsOut = false;
	}
}

void moveMobileGoalInAuto() {
	while (SensorValue[mobilePot] > 230) {
		motor[mobileGoal] = 127;
	}
	motor[mobileGoal] = 0;
}

void moveMobileGoalInDistance(int distance) {
	while (SensorValue[mobilePot] > distance) {
		motor[mobileGoal] = 127;
	}
	motor[mobileGoal] = 0;
}

void moveMobileGoalOut() {
	if (SensorValue[mobilePot] > 2000) {
		motor[mobileGoal] = -127;
		mobileGoalIsOut = false;
		} else {
		motor[mobileGoal] = -20;
		mobileGoalIsOut = true;
	}
}

void moveMobileGoalOutAuto() {
	while (SensorValue[mobilePot] < 2000) {
		motor[mobileGoal] = -127;
	}
	motor[mobileGoal] = 0;
}

void moveMobileGoalOutAndDrive(int speed, int distance) {
	while (SensorValue[rightDriveEnc] < distance && SensorValue[leftDriveEnc] < distance) {
		drive(speed, speed);
		while (SensorValue[mobilePot] < 2000) {
			motor[mobileGoal] = -127;
		}
		motor[mobileGoal] = 0;
	}
	drive(0, 0);

	SensorValue[rightDriveEnc] = 0;
	SensorValue[leftDriveEnc] = 0;
}

void moveMobileGoalInAndDrive(int speed, int distance) {
	while (SensorValue[rightDriveEnc] > distance && SensorValue[leftDriveEnc] > distance) {
		drive(speed, speed);
		while (SensorValue[mobilePot] > 180) {
			motor[mobileGoal] = 127;
		}
		motor[mobileGoal] = 0;
	}
	drive(0, 0);
}


void moveLiftUp(int speed, int distance) {
	if (((SensorValue[liftLeftPot] + SensorValue[liftRightPot])/2) < distance) {
		motor [liftL] = speed;
		motor [liftR] = speed;
		} else {
		motor [liftL] = 0;
		motor [liftR] = 0;
	}
}

void moveLiftUpAuto(int speed, int distance) {
	while (((SensorValue[liftLeftPot] + SensorValue[liftRightPot])/2) < distance) {
		motor [liftL] = speed;
		motor [liftR] = speed;
	}
	motor [liftL] = 0;
	motor [liftR] = 0;
}

void moveLiftDown(int speed, int distance) {
	if (((SensorValue[liftLeftPot] + SensorValue[liftRightPot])/2) > distance) {
		motor [liftL] = -speed;
		motor [liftR] = -speed;
		} else {
		motor [liftL] = 0;
		motor [liftR] = 0;
	}
}

void liftPIDControl (int position) {
	float leftCurrent;
	float rightCurrent;

	float integralAcitveZone = 100;

	float leftProportion;
	float sharedIntegral;
	float leftDerivative;
	float rightProportion;
	float rightDerivative;

	float liftLeftError;
	float liftRightError;
	float leftErrorT;
	float rightErrorT;
	float liftLeftLastError;
	float liftRightLastError;

	float leftPot = SensorValue[liftLeftPot];
	float rightPot = SensorValue[liftRightPot];

	//Find lift error
	liftLeftError = position - leftPot;
	liftRightError = position - rightPot;

	leftProportion = liftLeftError * liftLeftkp;
	rightProportion = liftRightError * liftRightkp;

	sharedIntegral = leftErrorT * liftSharedki;

	leftDerivative = (liftLeftError - liftLeftLastError) * liftLeftkd;
	rightDerivative = (liftRightError - liftRightLastError) * liftRightkd;

	//left
	if (abs(liftLeftError) < integralAcitveZone) {
		leftErrorT += liftLeftError;
		} else {
		leftErrorT = 0;
	}
	/*if (leftErrorT > 50/leftki) {
	leftErrorT = 50/leftki;
	}*/

	//right
	if (abs(liftRightError) < integralAcitveZone && abs(liftRightError) >= 10) {
		rightErrorT += liftRightError;
		} else {
		rightErrorT = 0;
	}
	/*if (rightErrorT > 50/rightki) {
	rightErrorT = 50/rightki;
	}*/

	/*if (abs(liftLeftError) <= leftPositionError) {
	leftDerivative = 0;
	}
	if (abs(liftRightError) <= rightPositionError) {
	rightDerivative = 0;
	}*/

	liftLeftLastError = liftLeftError;
	liftRightLastError = liftRightError;

	leftCurrent = leftProportion + sharedIntegral + leftDerivative;
	rightCurrent = rightProportion + sharedIntegral + rightDerivative;

	//left
	/*if (leftPot >= position + liftError && leftPot < position - liftError) {
	leftCurrent = 0;
	}

	//right
	if (rightPot >= position + liftError && rightPot < position - liftError) {
	rightCurrent = 0;
	}*/

	if (abs(liftLeftError) <= liftLeftPositionError) {
		leftCurrent = 0;
	}
	if (abs(liftRightError) <= liftRightPositionError) {
		rightCurrent = 0;
	}

	//Check that lift has stopped
	if (abs(liftLeftError) <= liftLeftPositionError) {
		liftLeftAtPosition = true;
		} else {
		liftLeftAtPosition = false;
	}
	if (abs(liftRightError) <= liftRightPositionError) {
		liftRightAtPosition = true;
		} else {
		liftRightAtPosition = false;
	}

	if (leftCurrent > 100) {
		leftCurrent = 100;
	}
	if (rightCurrent > 100) {
		rightCurrent = 100;
	}
	if (leftCurrent < -100) {
		leftCurrent = -100;
	}
	if (rightCurrent < -100) {
		rightCurrent = -100;
	}

	motor[liftL] = leftCurrent;
	motor[liftR] = rightCurrent;

	writeDebugStreamLine("left pot %d", leftPot);
	writeDebugStreamLine("             right pot %d", rightPot);
	//writeDebugStreamLine("arm %d", armIsReallyBack);
	//writeDebugStreamLine("  left integral %d", sharedIntegral);
	//writeDebugStreamLine("                          right integral %d", rightIntegral);
	//writeDebugStreamLine("position %d", position);
	//writeDebugStreamLine("          left error %d", liftLeftError);
	//writeDebugStreamLine("                  right error %d", liftRightError);
	writeDebugStreamLine("                     left curent %d", leftCurrent);
	writeDebugStreamLine("                                    right curent %d", rightCurrent);
}

void autoStackStep(int liftPos) {
	if (outakeFinished) {
		stacking = false;
		stackPrev = false;
		justStacked = true;
		liftLeftAtPosition = false;
		liftRightAtPosition = false;
		armIsReallyBack = false;
		increaseStackLvl = true;
		writeDebugStreamLine("stage 4");
		} else {
		if (!armIsReallyBack) {
			liftPIDControl(liftPos);
			writeDebugStreamLine("stage 1");
			} else if (time1[T1] <= 400) {
			motor[liftL] = -60;
			motor[liftR] = -60;
			} else if (time1[T1] >= 400) {
			rollerOutake(-127, 500);
			liftPIDControl(liftPos + 100);
			writeDebugStreamLine("Second Pid and Outake");
		}

		if (liftLeftAtPosition && liftRightAtPosition && !armIsReallyBack) {
			moveArmIn();
			//Not auto stacking stuff
			//armIsBack = false;
			SensorValue[rollerEnc] = 0;
			writeDebugStreamLine("stage 2");
			clearTimer(T1);
		}
	}
}

void autoStack(int level) {
	switch (level) {
	case PRESET_LEVEL_ONE:
		autoStackStep(500);
		break;

	case PRESET_LEVEL_TWO:
		autoStackStep(580);
		break;

	case PRESET_LEVEL_THREE:
		autoStackStep(800);
		break;

	case PRESET_LEVEL_FOUR:
		autoStackStep(960);
		break;

	case PRESET_LEVEL_FIVE:
		autoStackStep(1020);
		break;

	case PRESET_LEVEL_SIX:
		autoStackStep(1080);
		break;

	case PRESET_LEVEL_SEVEN:
		autoStackStep(1150);
		break;

	case PRESET_LEVEL_EIGHT:
		autoStackStep(1320);
		break;

	case PRESET_LEVEL_NINE:
		autoStackStep(1470);
		break;

	case PRESET_LEVEL_TEN:
		autoStackStep(1550);
		break;

	case PRESET_LEVEL_ELEVEN:
		autoStackStep(1750);
		break;

	case PRESET_LEVEL_TWELVE:
		autoStackStep(1970);
		break;

	case PRESET_LEVEL_THIRTEEN:
		autoStackStep(2020);
		break;
	}
}

void postStacking() {
	moveArmOut();
	//armIsBack = true;
	if (!armIsReallyBack) {
		if (SensorValue[liftLeftPot] > 270 && SensorValue[liftRightPot] > 270) {
			/*motor[liftL] = -70;
			motor[liftL] = -70;*/
			liftPIDControl(260);
		}
		} else {
		motor[liftL] = 0;
		motor[liftR] = 0;
	}
	if (SensorValue[liftLeftPot] <= 300 && SensorValue[liftRightPot] <= 300) {
		justStacked = false;
	}
	outakeFinished = false;
}

void autoDrivePIDControl (int distance, bool drive) {
	float encAverage = (SensorValue[leftDriveEnc]+SensorValue[rightDriveEnc])/2;

	float integralAcitveZone = 100;

	float error;
	float proportion;
	float integral;
	float derivative;

	float errorT;
	float lastError;

	float current;

	//Find Distance error
	error = distance - encAverage;

	if (drive) {
		//Set proportion
		proportion = error * drivekp;

		integral = errorT * driveki;

		derivative = (error - lastError) * drivekd;
		} else if (!drive) {
		//Set proportion for turn drive
		proportion = error * driveTurnkp;

		integral = errorT * driveTurnki;

		derivative = (error - lastError) * driveTurnkd;
	}

	//Calculate integral
	//left
	if (error < integralAcitveZone) {
		errorT += error;
		} else {
		errorT = 0;
	}

	lastError = error;

	//Set current
	current = proportion + integral + derivative;
	driveCurrent = proportion + integral + derivative;

	if (abs(error) <= drivePositionError) {
		current = 0;
	}

	if (abs(error) <= driveTurnPositionError) {
		gyroCurrent = 0;
	}

	//Check that drive has stopped
	if (abs(error) <= drivePositionError) {
		driveAtPosition = true;
		} else {
		driveAtPosition = false;
	}

	if (current > 127) {
		current = 127;
	}
	if (current < -127) {
		current = -127;
	}

	if (drive) {
		motor[driveBL] = current;
		motor[driveFL] = current;
		motor[driveBR] = current;
		motor[driveFR] = current;
	}

	//writeDebugStreamLine("Current Angle %d", encAverage);
	//writeDebugStreamLine("           drive  error %d", error);
	/*writeDebugStreamLine("             integral %d", integral);
	writeDebugStreamLine("             error total %d", errorT);
	writeDebugStreamLine("             derivative %d", derivative);
	writeDebugStreamLine("           last error %d", lastError);*/
	//writeDebugStreamLine("             drive current 2/ %d", current);
	writeDebugStreamLine("             proportion %d", proportion);
	writeDebugStreamLine("             error %d", error);

	/*datalogAddValueWithTimeStamp(0, error);
	datalogAddValueWithTimeStamp(1, encAverage);
	datalogAddValueWithTimeStamp(2, integral);
	datalogAddValueWithTimeStamp(3, derivative);
	datalogAddValueWithTimeStamp(4, current);*/
	datalogAddValueWithTimeStamp(5, error);
}

void autoGyroPIDControl (int setAngle, bool turn) {
	float currentAngle = SensorValue(driveGyro);

	float integralAcitveZone = 1000;

	float proportion;
	float integral;
	float derivative;

	float errorT;
	float lastError;

	float current;

	//Find Angle error
	turnError = setAngle - currentAngle;

	if (turn) {
		//Set proportion
		proportion = turnError * turnkp;

		integral = errorT * turnki;

		derivative = (turnError - lastError) * turnkd;
		} else if (!turn) {
		//Set proportion for turn drive
		proportion = turnError * turnDrivekp;

		integral = errorT * turnDriveki;

		derivative = (turnError - lastError) * turnDrivekd;
	}

	//Calculate integral
	if (turnError < integralAcitveZone) {
		errorT += turnError;
		} else {
		errorT = 0;
	}

	//Calculate derivative
	lastError = turnError;

	//Set current
	current = proportion + integral + derivative;
	gyroCurrent = proportion + integral + derivative;

	if (abs(turnError) <= turnPositionError) {
		current = 0;
	}

	//Check that lift has stopped
	if (abs(turnError) <= turnPositionError) {
		turnAtPosition = true;
		} else {
		turnAtPosition = false;
	}

	if (current > 90) {
		current = 90;
	}
	if (current < -90) {
		current = -90;
	}
	if (turn) {
		motor[driveBL] = -current;
		motor[driveFL] = -current;
		motor[driveBR] = current;
		motor[driveFR] = current;
	}

	//writeDebugStreamLine("Current Angle %d", currentAngle);
	//writeDebugStreamLine("            turn error %d", turnError);
	/*writeDebugStreamLine("             integral %d", integral);
	writeDebugStreamLine("             error total %d", errorT);
	writeDebugStreamLine("             derivative %d", derivative);
	writeDebugStreamLine("           last error %d", lastError);*/
	//writeDebugStreamLine("             angle current 2/ %d", current);

	datalogAddValueWithTimeStamp(4, turnError);
	/*datalogAddValueWithTimeStamp(1, currentAngle);
	datalogAddValueWithTimeStamp(2, integral);
	datalogAddValueWithTimeStamp(3, derivative);
	datalogAddValueWithTimeStamp(4, current);*/
	//datalogAddValueWithTimeStamp(4, turnError);
}

void autoDriveGyroPIDControl (int setAngle, int distance, float turnkp, float turnki, float turnkd, float drivekp, float driveki, float drivekd) {
	turnDrivekp = turnkp;
	turnDriveki = turnki;
	turnDrivekd = turnkd;

	driveTurnkp = drivekp;
	driveTurnki = driveki;
	driveTurnkd = drivekd;

	autoDrivePIDControl(distance, false);
	autoGyroPIDControl(setAngle, false);

	//Assign power to motors
	overallCurrentLeft = driveCurrent - gyroCurrent;
	overallCurrentRight = driveCurrent + gyroCurrent;

	motor[driveBL] = overallCurrentLeft;
	motor[driveFL] = overallCurrentLeft;
	motor[driveBR] = overallCurrentRight;
	motor[driveFR] = overallCurrentRight;

	//Limit power to motors
	if (gyroCurrent > turnPower) {
		gyroCurrent = turnPower;
	}
	if (gyroCurrent < -turnPower) {
		gyroCurrent = -turnPower;
	}

	if (abs(turnError) <= turnDrivePositionError) {
		gyroCurrent = 0;
	}

	if (driveCurrent > 127 - turnPower) {
		driveCurrent = 127 - turnPower;
	}
	if (driveCurrent < -(127 - turnPower)) {
		driveCurrent = -(127 - turnPower);
	}

	if (overallCurrentLeft > 127) {
		overallCurrentLeft = 127;
	}
	if (overallCurrentLeft < -127) {
		overallCurrentLeft = -127;
	}
	if (overallCurrentRight > 127) {
		overallCurrentRight = 127;
	}
	if (overallCurrentRight < -127) {
		overallCurrentRight = -127;
	}

	/*writeDebugStreamLine("Angle current %d", gyroCurrent);
	writeDebugStreamLine("Drive current %d", driveCurrent);
	writeDebugStreamLine("             overall  current left %d", overallCurrentLeft);
	writeDebugStreamLine("             overall  current right %d", overallCurrentRight);*/
	//writeDebugStreamLine("             gyro %d", SensorValue[driveGyro]);

	datalogAddValueWithTimeStamp(0, driveCurrent);
	datalogAddValueWithTimeStamp(1, gyroCurrent);
	datalogAddValueWithTimeStamp(2, overallCurrentLeft);
	datalogAddValueWithTimeStamp(3, overallCurrentRight);
}

void autoLiftPIDControl (int position, int kp, int ki, int kd) {
	float leftCurrent;
	float rightCurrent;

	float integralAcitveZone = 100;

	float leftProportion;
	float sharedIntegral;
	float leftDerivative;
	float rightProportion;
	float rightDerivative;

	float liftLeftError;
	float liftRightError;
	float leftErrorT;
	float rightErrorT;
	float liftLeftLastError;
	float liftRightLastError;

	float leftPot = SensorValue[liftLeftPot];
	float rightPot = SensorValue[liftRightPot];

	//Find lift error
	liftLeftError = position - leftPot;
	liftRightError = position - rightPot;

	leftProportion = liftLeftError * kp;
	rightProportion = liftRightError * kp;

	sharedIntegral = leftErrorT * ki;

	leftDerivative = (liftLeftError - liftLeftLastError) * kd;
	rightDerivative = (liftRightError - liftRightLastError) * kd;

	//left
	if (abs(liftLeftError) < integralAcitveZone) {
		leftErrorT += liftLeftError;
		} else {
		leftErrorT = 0;
	}

	//right
	if (abs(liftRightError) < integralAcitveZone && abs(liftRightError) >= 10) {
		rightErrorT += liftRightError;
		} else {
		rightErrorT = 0;
	}

	liftLeftLastError = liftLeftError;
	liftRightLastError = liftRightError;

	leftCurrent = leftProportion + sharedIntegral + leftDerivative;
	rightCurrent = rightProportion + sharedIntegral + rightDerivative;

	if (abs(liftLeftError) <= liftLeftPositionError) {
		leftCurrent = 0;
	}
	if (abs(liftRightError) <= liftRightPositionError) {
		rightCurrent = 0;
	}

	//Check that lift has stopped
	if (abs(liftLeftError) <= liftLeftPositionError) {
		liftLeftAtPosition = true;
		} else {
		liftLeftAtPosition = false;
	}
	if (abs(liftRightError) <= liftRightPositionError) {
		liftRightAtPosition = true;
		} else {
		liftRightAtPosition = false;
	}

	if (leftCurrent > 100) {
		leftCurrent = 100;
	}
	if (rightCurrent > 100) {
		rightCurrent = 100;
	}
	if (leftCurrent < -100) {
		leftCurrent = -100;
	}
	if (rightCurrent < -100) {
		rightCurrent = -100;
	}

	motor[liftL] = leftCurrent;
	motor[liftR] = rightCurrent;

	/*writeDebugStreamLine("left pot %d", leftPot);
	writeDebugStreamLine("             right pot %d", rightPot);
	//writeDebugStreamLine("arm %d", armIsReallyBack);
	writeDebugStreamLine("  integral %d", sharedIntegral);
	//writeDebugStreamLine("                          right integral %d", rightIntegral);
	//writeDebugStreamLine("position %d", position);
	//writeDebugStreamLine("          left error %d", liftLeftError);
	//writeDebugStreamLine("                  right error %d", liftRightError);
	writeDebugStreamLine("                     left curent %d", leftCurrent);
	writeDebugStreamLine("                                    right curent %d", rightCurrent);

	datalogAddValueWithTimeStamp(0, leftCurrent);
	datalogAddValueWithTimeStamp(1, rightCurrent);
	datalogAddValueWithTimeStamp(2, leftPot);
	datalogAddValueWithTimeStamp(3, rightPot);
	datalogAddValueWithTimeStamp(4, sharedIntegral);
	datalogAddValueWithTimeStamp(5, liftLeftError);
	datalogAddValueWithTimeStamp(6, liftLeftError);*/
}
